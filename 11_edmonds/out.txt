Chosen root 3
Starting Edmonson algorithm.
>> Outer iteration 0 with the following state: 
		 graph edges E= [(0, 1, 5.0), (0, 5, 1.0), (1, 4, 7.0), (2, 3, 2.0), (2, 1, 3.0), (3, 0, 7.0), (3, 1, 3.0), (3, 5, 8.0), (5, 2, 4.0)]
		 new nodes   W= [3]
		 new edges   F= []
		 all_covered_nodes: set()
BFS numbers: [1, 2, 5, 0, 4, 3]
Node with max number is node 2
Initializing path to empty
	 ** Inner iteration 0 started with the following state:
			 graph edges E= [(0, 1, 5.0), (0, 5, 1.0), (1, 4, 7.0), (2, 3, 2.0), (2, 1, 3.0), (3, 0, 7.0), (3, 1, 3.0), (3, 5, 8.0), (5, 2, 4.0)]
			 new nodes   W= [3]
			 new edges   F= []
			 all_covered_nodes: set()
			 X = 2
			 current_path_nodes Vp= []
			 current_path_edges Ep= []
		Minimum input edge into node x=2 is edge (5, 2, 4.0)
		This edge starts in node 5 which is not in Vp U W, therefore we put it as x and continue finding path.
	 ** Inner iteration 1 started with the following state:
			 graph edges E= [(0, 1, 5.0), (0, 5, 1.0), (1, 4, 7.0), (2, 3, 2.0), (2, 1, 3.0), (3, 0, 7.0), (3, 1, 3.0), (3, 5, 8.0), (5, 2, 4.0)]
			 new nodes   W= [3]
			 new edges   F= []
			 all_covered_nodes: set()
			 X = 5
			 current_path_nodes Vp= [2]
			 current_path_edges Ep= [(5, 2, 4.0)]
		Minimum input edge into node x=5 is edge (0, 5, 1.0)
		This edge starts in node 0 which is not in Vp U W, therefore we put it as x and continue finding path.
	 ** Inner iteration 2 started with the following state:
			 graph edges E= [(0, 1, 5.0), (0, 5, 1.0), (1, 4, 7.0), (2, 3, 2.0), (2, 1, 3.0), (3, 0, 7.0), (3, 1, 3.0), (3, 5, 8.0), (5, 2, 4.0)]
			 new nodes   W= [3]
			 new edges   F= []
			 all_covered_nodes: set()
			 X = 0
			 current_path_nodes Vp= [2, 5]
			 current_path_edges Ep= [(5, 2, 4.0), (0, 5, 1.0)]
		Minimum input edge into node x=0 is edge (3, 0, 7.0)
		This edge starts in node 3 which is in W (already added to tree). In this case we're done with inner iterations
		We flush the path nodes Vp into W and path edges Ep into F and also add edge (3, 0, 7.0)
		And we go all the way back to outer iterations.
>> Outer iteration 1 with the following state: 
		 graph edges E= [(0, 1, 5.0), (0, 5, 1.0), (1, 4, 7.0), (2, 3, 2.0), (2, 1, 3.0), (3, 0, 7.0), (3, 1, 3.0), (3, 5, 8.0), (5, 2, 4.0)]
		 new nodes   W= [0, 2, 3, 5]
		 new edges   F= [(3, 0, 7.0), (0, 5, 1.0), (5, 2, 4.0)]
		 all_covered_nodes: set()
BFS numbers: [1, 2, 5, 0, 4, 3]
Node with max number is node 4
Initializing path to empty
	 ** Inner iteration 0 started with the following state:
			 graph edges E= [(0, 1, 5.0), (0, 5, 1.0), (1, 4, 7.0), (2, 3, 2.0), (2, 1, 3.0), (3, 0, 7.0), (3, 1, 3.0), (3, 5, 8.0), (5, 2, 4.0)]
			 new nodes   W= [0, 2, 3, 5]
			 new edges   F= [(3, 0, 7.0), (0, 5, 1.0), (5, 2, 4.0)]
			 all_covered_nodes: set()
			 X = 4
			 current_path_nodes Vp= []
			 current_path_edges Ep= []
		Minimum input edge into node x=4 is edge (1, 4, 7.0)
		This edge starts in node 1 which is not in Vp U W, therefore we put it as x and continue finding path.
	 ** Inner iteration 1 started with the following state:
			 graph edges E= [(0, 1, 5.0), (0, 5, 1.0), (1, 4, 7.0), (2, 3, 2.0), (2, 1, 3.0), (3, 0, 7.0), (3, 1, 3.0), (3, 5, 8.0), (5, 2, 4.0)]
			 new nodes   W= [0, 2, 3, 5]
			 new edges   F= [(3, 0, 7.0), (0, 5, 1.0), (5, 2, 4.0)]
			 all_covered_nodes: set()
			 X = 1
			 current_path_nodes Vp= [4]
			 current_path_edges Ep= [(1, 4, 7.0)]
		Minimum input edge into node x=1 is edge (2, 1, 3.0)
		This edge starts in node 2 which is in W (already added to tree). In this case we're done with inner iterations
		We flush the path nodes Vp into W and path edges Ep into F and also add edge (2, 1, 3.0)
		And we go all the way back to outer iterations.
>> Outer iteration 2 with the following state: 
		 graph edges E= [(0, 1, 5.0), (0, 5, 1.0), (1, 4, 7.0), (2, 3, 2.0), (2, 1, 3.0), (3, 0, 7.0), (3, 1, 3.0), (3, 5, 8.0), (5, 2, 4.0)]
		 new nodes   W= [0, 1, 2, 3, 4, 5]
		 new edges   F= [(3, 0, 7.0), (1, 4, 7.0), (5, 2, 4.0), (0, 5, 1.0), (2, 1, 3.0)]
		 all_covered_nodes: set()
=====================================================================================================
Main algorithm finished.
W = [0, 1, 2, 3, 4, 5]
F = [(3, 0, 7.0), (1, 4, 7.0), (5, 2, 4.0), (0, 5, 1.0), (2, 1, 3.0)]
all_covered_nodes =
set()
Starting supernode expansion
Finally, all active edges are: [(0, 5, 1.0), (1, 4, 7.0), (2, 1, 3.0), (3, 0, 7.0), (5, 2, 4.0)]
